<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[ShareHub]]></title>
  <subtitle><![CDATA[悲观的意志,乐观的头脑]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/x-hansong//"/>
  <updated>2015-06-19T05:39:07.000Z</updated>
  <id>https://github.com/x-hansong//</id>
  
  <author>
    <name><![CDATA[Yonah-潇]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[算法学习之分治法(divide and conquer)]]></title>
    <link href="https://github.com/x-hansong/2015/06/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95-divide-and-conquer/"/>
    <id>https://github.com/x-hansong/2015/06/18/算法学习之分治法-divide-and-conquer/</id>
    <published>2015-06-18T10:50:50.000Z</published>
    <updated>2015-06-19T05:39:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是分治法">什么是分治法</h2><p>字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<h2 id="解决问题的流程">解决问题的流程</h2><img src="/2015/06/18/算法学习之分治法-divide-and-conquer/00.png" alt="[divide and conquer]" title="[divide and conquer]">
<h2 id="分治法适用情况">分治法适用情况</h2><pre><code>分治法所能解决的问题一般具有以下几个特征：

<span class="bullet">1. </span>该问题的规模缩小到一定的程度就可以容易地解决

<span class="bullet">2. </span>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

<span class="bullet">3. </span>利用该问题分解出的子问题的解可以合并为该问题的解；

<span class="bullet">4. </span>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。
</code></pre><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p>
<p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p>
<h2 id="应用问题">应用问题</h2><h3 id="归并排序">归并排序</h3><p>可以看到排序问题正好满足以上提到的四个特征。<br>归并排序通过将待排序数组分为两个部分，递归地处理它们，最终将两个排序好的部分合并起来。<br>值得一提的是归并排序通过数组的下标分割子问题，即每次都把数组分为两半。</p>
<p><strong>伪代码如下</strong><br><img src="/2015/06/18/算法学习之分治法-divide-and-conquer/01.png" alt="[merge_sort]" title="[merge_sort]"></p>
<img src="/2015/06/18/算法学习之分治法-divide-and-conquer/02.png" alt="[merge]" title="[merge]">
<p><strong>例子</strong><br><img src="/2015/06/18/算法学习之分治法-divide-and-conquer/03.png" alt="[例子]" title="[例子]"></p>
<h3 id="快速排序">快速排序</h3><p>跟归并排序的思想是类似的，但是快速排序是根据值来分割子问题，即把数组根据一个值分为大于和小于它两个部分。</p>
<p><strong>伪代码如下</strong></p>
<img src="/2015/06/18/算法学习之分治法-divide-and-conquer/04.png" alt="[quick_sort]" title="[quick_sort]">
<img src="/2015/06/18/算法学习之分治法-divide-and-conquer/05.jpg" alt="[partition]" title="[partition]">
<p><strong>例子</strong></p>
<img src="/2015/06/18/算法学习之分治法-divide-and-conquer/06.jpg" alt="[例子]" title="[例子]">
<h3 id="二分搜索">二分搜索</h3><p>对一个有序的数组进行二分搜索，每次比较中间的值，key大于它说明在右边，小于说明左边。</p>
<p><strong>伪代码如下</strong></p>
<img src="/2015/06/18/算法学习之分治法-divide-and-conquer/07.png" alt="[binary_search]" title="[binary_search]">
<p><strong>例子</strong></p>
<img src="/2015/06/18/算法学习之分治法-divide-and-conquer/08.png" alt="[例子]" title="[例子]">
<h3 id="大整数乘法">大整数乘法</h3><p>对于任意位数的2个数相乘 $a * b$ ，写成：<br><span>$$a = a_{1} * 10^{(n_{1}/2)} + a_{0}$$</span><!-- Has MathJax --><br>$n_{1}$为$a$的位数</p>
<span>$$b = b_{1} * 10^{(n_{2}/2)} + b_{0}$$</span><!-- Has MathJax -->
<p>$n_{2}$为$b$的位数</p>
<p>分治策略就是基于以上变换，将a，b写成前一半数字和后一半数字相加的形式，例如若$a = 5423678$，那么$a_{1} = 542$  $a_{0} = 3678$（注意若不是偶数截取较小一半）</p>
<p>这样a和b相乘就可以写为：<br><span>$$a * b = { a_{1} * 10^{(n_{1}/2)} + a_{0} } * { b_{1} * 10^{(n_{2}/2)} + b_{0} }$$</span><!-- Has MathJax --><br>展开后整理得：<br><span>$$a * b = a_{1}*b_{1} * 10^{[(n_{1}+n_{2})/2]} + a_{1}*b_{0} * 10^{(n_{1}/2)} + a_{0}*b_{1} * 10^{(n_{2}/2)} + a_{0}*b_{0}$$</span><!-- Has MathJax --><br>这样就很容易递归的来求$a * b$，如果嫌分解后的数还太大，就可以继续分解。（你可以自己规定在何时结束递归）</p>
<h2 id="总结">总结</h2><p>分治法实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p>
<ol>
<li>一定是先找到最小问题规模时的求解方法</li>
<li>然后考虑随着问题规模增大时的求解方法</li>
<li>找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</li>
</ol>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html" target="_blank" rel="external">五大常用算法之一：分治算法</a></p>
<p><a href="http://www.cnblogs.com/kkgreen/archive/2011/06/12/2078668.html" target="_blank" rel="external">大整数乘法和Strassen矩阵乘法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是分治法">什么是分治法</h2><p>字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<h2 id="解决问题的流程">解决问题的流程</h2><i]]>
    </summary>
    
      <category term="分治法" scheme="https://github.com/x-hansong/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
      <category term="算法学习" scheme="https://github.com/x-hansong/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习之暴力求解(brute force)]]></title>
    <link href="https://github.com/x-hansong/2015/06/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3-brute-force/"/>
    <id>https://github.com/x-hansong/2015/06/18/算法学习之暴力求解-brute-force/</id>
    <published>2015-06-18T08:53:51.000Z</published>
    <updated>2015-06-18T09:02:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="暴力求解(brute_force)">暴力求解(brute force)</h2><blockquote>
<p>Brute force is a straightforward approach to solving a problem, usually directly based on the problem statement and definitions of the concepts involved.</p>
</blockquote>
<p>暴力求解即根据问题的描述和定义直接求解,不使用一些特殊的算法.</p>
<h3 id="排序问题的应用">排序问题的应用</h3><ul>
<li><p>选择排序<br>选择排序将数组分为排序与未排序两个部分,每次将从未排序部分取出最小的值,插入排序部分的最后,最终未排序部分消失,排序完成.</p>
</li>
<li><p>冒泡排序<br>冒泡排序也是将数组分为排序与未排序两个部分,每次从未排序部分的第一个数开始,与后一个比较,如果大于它两两交换,否则从第二个开始继续与后一个比较.最终未排序部分的最后一个数即最大的数.循环n次即完成排序.</p>
</li>
</ul>
<h3 id="搜索问题的应用">搜索问题的应用</h3><ul>
<li><p>线性搜索<br>简单粗暴,一个个比较.</p>
</li>
<li><p>字符串匹配<br>同样道理,逐个比较.</p>
</li>
</ul>
<h3 id="几何问题">几何问题</h3><ul>
<li><p>最近点问题<br>把所有两点距离求出来,然后选择最小值.</p>
</li>
<li><p>凸包问题<br>用循序渐进的方式求取给定点集的凸包，首先把最初输入的3个不共线(Non-collinear)的点按 逆时针方向构成一个三角形，这就是这3点的凸包。接着便会考察第4点，看看这个点是否位于前述三 角形之内或三角形的边上。若是，则这第4点并非凸包上的点，前述三角形保持不变。若否，则把这前述的三角 形扩大为一个四边形，并把不适用的边擦去。这个四边形便是这首4点的凸包。接着程序又会考察第5点，如此 类推，直至所有点均已被考察为止.由于每次都要检查所有之前的点，时间复杂度为O(n^2).</p>
</li>
</ul>
<h3 id="穷举搜索">穷举搜索</h3><p>以下3个问题都可以用穷举的方法暴力求解,把所有可能都试一遍.然而实际上由于可能情况太多,一般不会使用穷举的方法.数据量小的情况可以考虑使用.每个问题都有不少更优的算法.</p>
<ul>
<li><p>旅行推销员问题(Travelling Salesman Problem)    有n个城市，一个推销员要从其中某一个城市出发，唯一走遍所有的城市，再回到他出发的城市，求最短的路线。也即求一个最短的哈密顿回路。</p>
</li>
<li><p>背包问题(knapsack problem)<br>给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p>
</li>
<li><p>任务分配问题(assignment problem)<br>线性任务分配问题：P是二元组(a, b)的集合，其中a和b分别是集合A和B中的元素。C是某一函数，并满足特定约束条件，例如：A的每一个元素必须在P中出现一次，或者B的每一个元素必须在P中出现一次，或者以上二者都必须满足。线性任务分配问题的目标就是最大化或者最小化C(a, b)之和。</p>
</li>
</ul>
<h3 id="总结">总结</h3><pre><code>暴力求解法可以说毫无技巧,但是简单容易实现.一般情况是不会用到的,但是在特定情况下有奇效.可以说当人们解决某个问题的时候用暴力求解应该是第一直觉,然而这太简单并不能体现自己的能力,就会开始寻找更快的方法.我的理解是更优的算法应该是基于暴力求解法之上的.例如说背包问题,同样样遍历所有情况,动态规划巧妙的利用前面的尝试过的数据,减少了工作量.但本质上还是要试遍所有可能,只是试的少了.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="暴力求解(brute_force)">暴力求解(brute force)</h2><blockquote>
<p>Brute force is a straightforward approach to solving a problem, usually dir]]>
    </summary>
    
      <category term="暴力求解" scheme="https://github.com/x-hansong/tags/%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3/"/>
    
      <category term="算法学习" scheme="https://github.com/x-hansong/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习之算法基本概念]]></title>
    <link href="https://github.com/x-hansong/2015/06/18/%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://github.com/x-hansong/2015/06/18/算法基本概念/</id>
    <published>2015-06-18T08:18:24.000Z</published>
    <updated>2015-06-18T08:58:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="算法的定义">算法的定义</h2><blockquote>
<p>An algorithm is a sequence of unambiguous instructions for solving a problem</p>
</blockquote>
<p>即算法是解决问题的无二义性的指令序列.简单说就是用来解决问题步骤.</p>
<h2 id="算法设计及实现流程">算法设计及实现流程</h2><p><img src="http://img.blog.csdn.net/20150615181318512" alt="算法设计及实现流程"></p>
<h2 id="重要的问题类型">重要的问题类型</h2><ul>
<li>Sorting</li>
<li>Searching</li>
<li>String processing</li>
<li>Graph problems</li>
<li>Combinatorial problems</li>
<li>Geometric problems</li>
<li>Numerical Problems</li>
</ul>
<h2 id="基础数据结构">基础数据结构</h2><ul>
<li>linear data structure<ul>
<li>array</li>
<li>list</li>
<li>stack</li>
<li>queue</li>
</ul>
</li>
<li>graphs</li>
<li>tree</li>
<li>set and dictionaries</li>
</ul>
<h2 id="常用的算法思想">常用的算法思想</h2><ul>
<li>Brute force (暴力求解)</li>
<li>Divide and conquer (分治法)</li>
<li>Decrease and conquer (减治法)</li>
<li>Transform and conquer (转治法)</li>
<li>Space and time tradeoffs (时空权衡)</li>
<li>Greedy approach (贪婪算法)</li>
<li>Dynamic programming (动态规划)</li>
<li>Iterative improvement (迭代改进)</li>
<li>Backtracking (回溯法)</li>
<li><p>Branch and bound (分支界限法)</p>
<p>  基本上,算法就是围绕上面提到的问题和数据结构进行研究,遇到某个问题时,先分析问题,确定问题类型和使用的数据结构,有利于快速找到头绪.</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="算法的定义">算法的定义</h2><blockquote>
<p>An algorithm is a sequence of unambiguous instructions for solving a problem</p>
</blockquote>
<p>即]]>
    </summary>
    
      <category term="算法" scheme="https://github.com/x-hansong/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="https://github.com/x-hansong/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用hexo搭建github博客]]></title>
    <link href="https://github.com/x-hansong/2015/06/17/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/x-hansong/2015/06/17/用hexo搭建github博客/</id>
    <published>2015-06-17T02:14:18.000Z</published>
    <updated>2015-06-18T13:32:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p><strong>搭建环境:Linux,nodejs,npm,git</strong></p>
<p>现在网上已经有很多关于搭建hexo github博客的文章,我自己也是参考别人的文章过来的,但是现在hexo已经到了3.0版本,很多教程都过时了,而且感觉他们教程的思路着重于怎么做,并没有说明背后的原因,所以我希望写一篇着重于<strong>为什么</strong>,而不是怎么做的文章.我相信只有理解背后的原理才能更好更快的上手.</p>
<p>其次,最好的教程就是官方文档,所以在这篇文章我引用的都是官方文档的内容,而且只是提供思路,不提供详细步骤.因为版本更新之后,操作是不一样的,官方文档会随时更新,但是这篇文章不一定会随时更新,然而思路是不变的,所以我极力推荐大家首先阅读官方文档.</p>
<h2 id="什么是Github_Page">什么是Github Page</h2><p>首先,所谓的github博客是通过github page来实现的.</p>
<p>简单的说，Github是一个具有版本管理功能的代码仓库，每个项目都有一个主页，列出项目的源文件。</p>
<p>但是对于一个新手来说，看到一大堆源码，只会让人头晕脑涨，不知何处入手。<br>他希望看到的是，一个简明易懂的网页，说明每一步应该怎么做。</p>
<p>因此，github就设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。</p>
<p>所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。</p>
<h2 id="什么是Hexo">什么是Hexo</h2><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<p>我们主要是用hexo在本地写博客,然后上传到github page,就像你commit项目代码到github一样.</p>
<h1 id="操作">操作</h1><h2 id="建立一个Github_page">建立一个Github page</h2><p>首先注册个github账户,然后在本地配置ssh到github,这一步自行google.</p>
<blockquote>
<h2 id="Create_a_repository">Create a repository</h2><p>Head over to GitHub and create a new repository named username.github.io, where username is your username (or organization name) on GitHub.</p>
<p>If the first part of the repository doesn’t exactly match your username, it won’t work, so make sure to get it right.</p>
</blockquote>
<p>官方教程主要强调命名项目的格式,即一定要命名为 username.github.io<br>同时,建完项目之后不要进行任何操作.我们可以直接用hexo初始化项目.</p>
<h2 id="安装配置hexo">安装配置hexo</h2><p>这一步强烈推荐看<a href="http://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo 官方文档</a>,现在很多网上的安装过程是过时的,现在hexo是3.0了.<br>请耐心的看完官方文档以下内容<br><img src="/2015/06/17/用hexo搭建github博客/00.png" alt="[官方文档目录]" title="[官方文档目录]">_</p>
<p>由于hexo3.0很多功能都插件化了,包括git上传,server功能.<br>所以我们要把博客上传到github就需要先装git插件,详细见<a href="http://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="external">部署</a>(切记要根据文档配置config.yml)<br>以下是常用插件</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-generator-archive <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-generator-category <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-generator-tag <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-<span class="keyword">server</span> <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-renderer-marked@<span class="number">0.2</span> <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-renderer-stylus@<span class="number">0.2</span> <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-generator-feed@<span class="number">1</span> <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-generator-sitemap@<span class="number">1</span> <span class="comment">--save</span></span>
</code></pre><p>在命令行执行即可</p>
<h2 id="用hexo写作github博客的流程">用hexo写作github博客的流程</h2><p><strong>注意:hexo是用markdown来写作的,以下命令都是博客所在目录执行</strong></p>
<ol>
<li>hexo new “title” <ul>
<li>新建一篇文章,然后编辑相应的md文件</li>
<li>具体使用查看<a href="http://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="external">写作</a></li>
</ul>
</li>
<li>hexo clean <ul>
<li>清除缓存</li>
</ul>
</li>
<li>hexo generate<ul>
<li>根据写作的内容和配置生成网页</li>
<li>生成文章在public文件夹中,上传到github的就是里面的内容</li>
<li>具体使用查看<a href="http://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="external">生成器</a></li>
</ul>
</li>
<li>hexo deploy <ul>
<li>上传到github</li>
<li>具体使用查看<a href="http://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="external">部署</a></li>
</ul>
</li>
<li>访问username.github.io查看内容</li>
</ol>
<h2 id="hexo与github的关系">hexo与github的关系</h2><p>hexo是一个博客框架,给我们提供了基于markdown的语法,帮助我们自动生成博客.</p>
<p>由于github提供了github page的功能,那么我们可以把生成的博客网页放在github上,供大家访问.</p>
<p>也就是说github就像是一个网站空间,由于hexo自带对github的支持,可以直接commit内容到github上,也就是说我们可以把hexo当做集成了写作和ftp发布功能的软件.</p>
<h2 id="hexo的主题">hexo的主题</h2><p>hexo有丰富的主题支持,本博客用的就是<a href="http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/" target="_blank" rel="external">jacman</a></p>
<p>更多主题查看<a href="http://hexo.io/themes/" target="_blank" rel="external">主题</a></p>
<h1 id="总结">总结</h1><p>整个部署流程如下</p>
<ul>
<li>注册github</li>
<li>创建 username.github.io</li>
<li>安装配置hexo</li>
<li>开始写作</li>
<li>额外配置主题</li>
</ul>
<p>总的来说,刚开始配置就是一直在折腾,需要有足够的耐心,可能大家都喜欢看别人一步步的详细的步骤,自己只要复制粘贴就行了.但是有时候即使你完全照着做也会出问题的,因为版本和环境不一样.</p>
<p>一开始我也是这样,后来才发现,最好的方法是查看别人做的思路,然后去找官方的文档.这样遇到的问题会大大减少,有时候你纠结半天的问题可能只是版本不一样.就像前面deploy部署,所有文章都是没有提到要先装</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span>
</code></pre><p>因为hexo3.0把它插件化了,然后我在官方文档找到了答案.<br><strong>最后提示一下：如果运行命令出现什么问题，加上sudo试试看看，里面有些需要root权限</strong></p>
<p>仅以此文记录折腾hexo的过程,并且希望给后来者有参考价值.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="背景">背景</h1><p><strong>搭建环境:Linux,nodejs,npm,git</strong></p>
<p>现在网上已经有很多关于搭建hexo github博客的文章,我自己也是参考别人的文章过来的,但是现在hexo已经到了3.0版本,很多教程]]>
    </summary>
    
      <category term="hexo github" scheme="https://github.com/x-hansong/tags/hexo-github/"/>
    
      <category term="Hexo" scheme="https://github.com/x-hansong/categories/Hexo/"/>
    
  </entry>
  
</feed>